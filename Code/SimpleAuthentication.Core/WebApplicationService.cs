using System;
using System.Diagnostics;
using System.Threading.Tasks;
using SimpleAuthentication.Core.Config;
using SimpleAuthentication.Core.Exceptions;
using SimpleAuthentication.Core.Providers;
using SimpleAuthentication.Core.Tracing;

namespace SimpleAuthentication.Core
{
    public class WebApplicationService
    {
        private readonly AuthenticationProviderFactory _authenticationProviderFactory;
        private readonly string _callbackRoute;
        private readonly TraceSource _traceSource;

        public WebApplicationService(IConfigService configService,
            TraceSource traceSource,
            string callbackRoute)
        {
            if (configService == null)
            {
                throw new ArgumentNullException("configService");
            }

            if (traceSource == null)
            {
                throw new ArgumentNullException("traceSource");
            }

            _authenticationProviderFactory = new AuthenticationProviderFactory(configService);
            _traceSource = traceSource;

            _callbackRoute = callbackRoute;
        }

        public RedirectToProviderResult RedirectToProvider(RedirectToProviderData redirectToProviderData)
        {
            if (redirectToProviderData == null)
            {
                throw new ArgumentNullException("redirectToProviderData");
            }

            // Grab the Provider.
            var provider = GetAuthenticationProvider(redirectToProviderData.ProviderKey);

            // Where do we return to, after we've authenticated?
            var callbackUri = GenerateCallbackUri(redirectToProviderData.RequestUrl, _callbackRoute);

            // Determine where we need to redirect to.
            var redirectToAuthenticateSettings = provider.GetRedirectToAuthenticateSettings(callbackUri);
            if (redirectToAuthenticateSettings == null)
            {
                // We failed to determine where to go. A classic example of this is with OpenId and a bad OpenId endpoint.
                const string errorMessage =
                    "No redirect to authencate settings retrieved. This means we don't know where to go. A classic example of this is with OpenId and a bad OpenId endpoint. Please check the data you are providing to the Controller. Otherwise, you will need to debug the individual provider class you are trying use to connect with.";
                _traceSource.TraceError(errorMessage);
                throw new AuthenticationException(errorMessage);
            }

            // Remember any important information for later, after we've returned back here.
            var cacheData = new CacheData(redirectToProviderData.ProviderKey,
                redirectToAuthenticateSettings.State,
                DetermineReturnUrl(redirectToProviderData.ReturnUrl,
                    redirectToProviderData.Referer));

            return new RedirectToProviderResult(redirectToAuthenticateSettings.RedirectUri,
                cacheData);
        }

        public async Task<dynamic> AuthenticateCallbackAsync(AuthenticateCallbackAsyncData data)
        {
            if (data == null)
            {
                throw new ArgumentNullException("data");
            }

            _traceSource.TraceVerbose("Retrieving Cache values - State and RedirectToUrl.");

            _traceSource.TraceInformation("Previous CacheData: {0}",
                data.CacheData == null
                    ? "--no cache data"
                    : data.CacheData.ToString());

            // If we don't have some previous state value cached, then it's possible we're trying to just
            // hack into the callback directly. ie. CSRF.
            if (data.CacheData == null ||
                string.IsNullOrWhiteSpace(data.CacheData.State))
            {
                throw new AuthenticationException(
                    "No cache data or cached State value was found which generally means that a Cross Site Request Forgery attempt might be made. A 'State' value is generated by the server when a client prepares to rediect to an Authentication Provider and passes that generated state value to that Provider. The provider then passes that state value back, which proves that the client (ie. that's -you-) have actually authenticated against a provider. Otherwise, anyone can just hit the callback Url and impersonate another user, bypassing the authentication stage. So what's the solution: make sure you call the 'RedirectToProvider' endpoint *before* you hit the 'AuthenticateCallbackAsync' callback endpoint.");
            }

            dynamic result;

            try
            {
                var model = await RetrieveUserInformation(data);

                // Do we have an optional redirect resource? Usually a previous referer?
                if (!string.IsNullOrWhiteSpace(data.CacheData.ReturnUrl))
                {
                    _traceSource.TraceVerbose("Found return url: " + data.CacheData.ReturnUrl);
                    model.ReturnUrl = data.CacheData.ReturnUrl;
                }

                // Finally! We can hand over the logic to the consumer to do whatever they want.
                _traceSource.TraceVerbose("About to execute your custom callback provider logic.");

                // TODO: PHILLIP: This is the money shot .. where **their** code is called.
                //       Because this class is framework agnostic ... I'm not sure how to 
                //       call the appropriate interface method.
                result = _providerCallback.Process(data.ControllerOrModule, model);
            }
            catch (Exception exception)
            {
                _traceSource.TraceError(exception.Message);
                result = _providerCallback.OnRedirectToAuthenticationProviderError(exception);
            }

            return result;
        }

        private IAuthenticationProvider GetAuthenticationProvider(string providerKey)
        {
            if (string.IsNullOrEmpty(providerKey))
            {
                throw new ArgumentNullException("providerKey");
            }

            _traceSource.TraceVerbose("Trying to retrieve a provider for the given key: " + providerKey);

            IAuthenticationProvider provider = null;

            // Dictionary keys are case sensitive.
            var key = providerKey.ToLowerInvariant();

            if (_authenticationProviderFactory.AuthenticationProviders.ContainsKey(key))
            {
                _traceSource.TraceVerbose("Found registered provider: " + key);
                provider = _authenticationProviderFactory.AuthenticationProviders[key];
            }
            else if (providerKey.StartsWith("fake", StringComparison.InvariantCultureIgnoreCase))
            {
                // Ah-ha! We've been asked for a fake key :P
                _traceSource.TraceVerbose("Request for a *Fake* provider. Creating the fake provider: " + providerKey);
                provider = new FakeProvider(providerKey);
            }

            // So, did we get a real or fake key?
            if (provider == null)
            {
                var errorMessage = string.Format("There was no provider registered for the given key: {0}.", providerKey);
                _traceSource.TraceError(errorMessage);
                throw new InvalidOperationException(errorMessage);
            }

            _traceSource.TraceVerbose("Found - Provider: {0}.",
                string.IsNullOrEmpty(provider.Name)
                    ? "-no provider name-"
                    : provider.Name);

            return provider;
        }

        private static Uri GenerateCallbackUri(Uri requestUri,
            string callbackRoute,
            string query = null)
        {
            // Optional, but UriBuilder doesn't like a null query value.
            if (query == null)
            {
                query = string.Empty;
            }

            var builder = new UriBuilder(requestUri)
            {
                Path = callbackRoute,
                Query = query
            };

            // Don't include port 80/443 in the Uri.
            if (builder.Uri.IsDefaultPort)
            {
                builder.Port = -1;
            }

            return builder.Uri;
        }

        private static string DetermineReturnUrl(string returnUrl,
            string referer)
        {
            // LOGIC: The idea here is that if we have a return url, then we will go there.
            //        Otherwise, we'll try falling back to the referer, if that was provided.
            //        Finally - nothing was provided, then nowhere to go.
            return !string.IsNullOrEmpty(returnUrl)
                ? returnUrl
                : !string.IsNullOrWhiteSpace(referer)
                    ? referer
                    : null;
        }

        private async Task<AuthenticateCallbackResult> RetrieveUserInformation(AuthenticateCallbackAsyncData data)
        {
            if (data == null)
            {
                throw new ArgumentNullException("data");
            }

            // Which provider did we just authenticate with?
            var provider = GetAuthenticationProvider(data.CacheData.ProviderKey);

            // CRAZY?? Yeah, we still need the callback uri (even though we're -IN- the callback
            // because some providers use that as some security check or something. Urgh...
            var callbackUri = GenerateCallbackUri(data.RequestUrl, _callbackRoute);

            // Grab the user information.
            var model = new AuthenticateCallbackResult
            {
                AuthenticatedClient = await provider.AuthenticateClientAsync(data.QueryStringKeyValues,
                    data.CacheData.State,
                    callbackUri)
            };

            return model;
        }
    }
}